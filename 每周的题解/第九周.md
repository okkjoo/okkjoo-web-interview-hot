`okkjoo-leetcodeHot-byJs`带你用 JS 刷高频面试算法题~ 合集仓库：[okkjoo-leetcodeHot-byJs](https://github.com/okkjoo/okkjoo-leetcodeHot-byJs)
如果你已经按题型分类系统地刷了一遍算法面试题的各个题型，想感受一下面试题的”随机性”的话，欢迎一起~

## 31. 下一个排列|双指针

### 题目描述

```
整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。

例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。
整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。
类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。
而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。
给你一个整数数组 nums ，找出 nums 的下一个排列。

必须 原地 修改，只允许使用额外常数空间。
```

### 解题思路

首先，如果当前值不是最大值，那么就要找一个大一点，但是又只大一点点的，即幅度尽可能小，这样才是下一个排列。

那么要交换的两个值，在前面的就要比较小，在后面的就要比较大 —— 这样交换后才是变大。

并且

- 前面较小值`nums[i]`尽量靠右边
- 后面较大值`nums[j]`尽量小
- 交换位置后，让`i~n`的顺序为升序

这样才能让变大的幅度尽可能变小

具体怎么找？

- 首先从后往前找 i 的位置，就是第一个符合`nums[i] < nums[i + 1]`的 i， —— 那么`i+1 ~ n`都是降序
- 然后再从后往前找第一个大于`num[i]`的数，就是最靠右的较大值了
- 然后翻转`i+1 ~ n`的数就好了，上面已经证明是降序了，翻转就是升序

还要注意的是，如果 i 的值为 0，就说明，整体都是降序，也就已经是所有排列中最大的值了，直接翻转变为最小值即可

### 代码

```js
var nextPermutation = function (nums) {
	const n = nums.length - 1;
	let i = n - 1;
	while (i >= 0 && nums[i] >= nums[i + 1]) i--;
	if (i >= 0) {
		let j = n;
		while (j >= 0 && nums[i] >= nums[j]) j--;
		[nums[i], nums[j]] = [nums[j], nums[i]];
	}
	//JS的reverse不能翻转一部分...
	let l = i + 1,
		r = n;
	while (l < r) {
		[nums[l], nums[r]] = [nums[r], nums[l]];
		l++, r--;
	}
};
```

## 122. 买卖股票的最佳时机 II|贪心

### 题目描述

```
给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。

返回 你能获得的 最大 利润 。
```

### 解题思路

买股票嘛，人人都懂的，低买高卖
这道题和 [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)的区别在于，这里可以多次交易，之前那道只能买卖一次。

那么我们在每次下跌之前买出，下跌之后，且后面会涨之前买入即可

那在题目里，不就是 每次有上涨的空间就收入囊中就好了

### 代码

```js
var maxProfit = function (prices) {
	let profit = 0;
	for (let i = 1; i < prices.length; i++) {
		if (prices[i] > prices[i - 1]) {
			profit += prices[i] - prices[i - 1];
		}
	}
	return profit;
};
```
