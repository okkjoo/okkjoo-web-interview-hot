> `okkjoo-leetcodeHot-byJs`带你用 JS 刷高频面试算法题~
> 还有各种常用、常考手写, 最近还加了自己实现的流行库的 mini 版本
> 合集仓库：[okkjoo-leetcodeHot-byJs](https://github.com/okkjoo/okkjoo-leetcodeHot-byJs)
> 欢迎 star⭐

## 862. 和至少为 K 的最短子数组

### 题目描述

```js
给你一个整数数组 nums 和一个整数 k ，找出 nums 中和至少为 k 的 最短非空子数组 ，并返回该子数组的长度。如果不存在这样的 子数组 ，返回 -1 。

子数组 是数组中 连续 的一部分。
```

### 解题思路

和至少为 k，就是 >=k 呗
你要求子数组，如果每次都遍历一遍获取子数组的值，那自然是 O(N)的时间复杂度，但你可以用前缀和

> 知识点：前缀和 `s[i] = s[1]+s[2]+..s[i]`

这样一来，子数组的和就转换为了两个前缀和之间的相减

而要找最短的 —— 看起来还是要两个 for 遍历一遍所有子数组 —— 但这可是 O(n^2)

以`i<j`为例子，也就是`[i,j]`为子数组
首先如果`[i, j]`已经满足了 `>=k`，那以 i 为左边界的情况下，j 继续往后走 子数组都不可能找到短于`[i,j]`的了 —— 这个应该很好理解吧

所以此时就可以直接不看 i 了，把他丢掉

如果遇到负数，也就是 `s[i]>s[j]`，那 j 继续往后走的话，比如走到 k，如果`s[k]-s[i]>=k`，那`s[k]-s[j]`肯定也>=k 了，所以肯定比从 i 开始短，要它何用，丢掉

那么我们需要灵活地在左右边界增删—— 那就是双端队列—— JS 数组自己就能干

### 代码

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var shortestSubarray = function (nums, k) {
	const n = nums.length;
	let ans = n + 1;
	const s = new Array(n + 1); //前缀和
	s[0] = 0;
	for (let i = 0; i < n; i++) {
		s[i + 1] = s[i] + nums[i];
	}
	const q = []; //可以做区间左边界的下标的双端队列
	for (let i = 0; i <= n; i++) {
		//i就是区间的右边界
		const curs = s[i];
		while (q.length && curs - s[q[0]] >= k) {
			ans = Math.min(ans, i - q[0]);
			q.shift();
		}
		while (q.length && s[q[q.length - 1]] >= curs) {
			q.pop();
		}
		q.push(i);
	}
	return ans > n ? -1 : ans;
};
```

## 1822. 数组元素积的符号

### 题目描述

```
已知函数 signFunc(x) 将会根据 x 的正负返回特定值：

如果 x 是正数，返回 1 。
如果 x 是负数，返回 -1 。
如果 x 是等于 0 ，返回 0 。
给你一个整数数组 nums 。令 product 为数组 nums 中所有元素值的乘积。

返回 signFunc(product) 。
```

### 解题思路

两个点：

- 只要有 0 ，答案就是 0
- 正数根本不影响

没 0 的情况下，负数的个数为偶数的话答案就是 1，不然就是-1

### 代码

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var arraySign = function (nums) {
	let cnt = 0;
	for (const num of nums) {
		if (num === 0) return 0;
		if (num < 0) cnt++;
	}
	return cnt % 2 === 0 ? 1 : -1;
};
```
