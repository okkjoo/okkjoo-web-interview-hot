`okkjoo-leetcodeHot-byJs`带你用 JS 刷高频面试算法题~
新版板块 —— 各种常用手写
合集仓库：[okkjoo-leetcodeHot-byJs](https://github.com/okkjoo/okkjoo-leetcodeHot-byJs)
如果你已经按题型分类系统地刷了一遍算法

## 443. 压缩字符串|双指针|字符串

### 题目描述

```
给你一个字符数组 chars ，请使用下述算法压缩：

从一个空字符串 s 开始。对于 chars 中的每组 连续重复字符 ：

如果这一组长度为 1 ，则将字符追加到 s 中。
否则，需要向 s 追加字符，后跟这一组的长度。
压缩后得到的字符串 s 不应该直接返回 ，需要转储到字符数组 chars 中。需要注意的是，如果组长度为 10 或 10 以上，则在 chars 数组中会被拆分为多个字符。

请在 修改完输入数组后 ，返回该数组的新长度。

你必须设计并实现一个只使用常量额外空间的算法来解决此问题。
```

### 解题思路

最容易想到的就是：

边读边用二维数组存` [连续的字母, 及其出现的次数]`

但这样空间复杂度就高了，想想有没有复杂度为 1 的方法呢？

通常想在 O(1)空间操作字符串，就需要用到双指针~

一个快的读指针往前走，一个慢的写指针在后面
读指针读完一串连续的字母之后，慢指针在当前位置往后写上字母及其出现的次数

要注意特别处理

> 如果组长度为 10 或 10 以上，则在 chars 数组中会被拆分为多个字符。

你可以一位一位取，也可以直接用 js 的 API，把数字转为字符串再转为数组（这种空间消耗仍算是常数级别的）

### 代码

```js
/**
 * @param {character[]} chars
 * @return {number}
 */
var compress = function (chars) {
	let write = 0,
		read,
		tcnt = 1; //注意这里从1开始
	for (read = 0; read < chars.length; read++) {
		if (read === chars.length - 1 || chars[read] !== chars[read + 1]) {
			chars[write++] = chars[read];
			if (tcnt > 1) {
				tcnt = tcnt + '';
				for (let s of tcnt) {
					chars[write++] = s;
				}
			}
			tcnt = 0;
		}
		tcnt++;
	}
	return write;
};
```
