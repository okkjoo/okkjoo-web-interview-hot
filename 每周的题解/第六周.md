`okkjoo-leetcodeHot-byJs`带你用 JS 刷高频面试算法题~ 合集仓库：[okkjoo-leetcodeHot-byJs](https://github.com/okkjoo/okkjoo-leetcodeHot-byJs)
如果你已经按题型分类系统地刷了一遍算法面试题的各个题型，想感受一下面试题的”随机性”的话，欢迎一起~

## 25. K 个一组翻转链表|链表|困难|模拟

### 题目描述

```
给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。

k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
```

### 解题思路

回顾一下 反转链表 Ⅱ 那道题,将链表中的一个区间反转

其实我们这里就是反转多个长度为 k 的区间罢了

具体多少个区间，就是链表总长度和 k 的关系了

### 代码

```js
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var reverseKGroup = function (head, k) {
	const len = getListLength(head);
	let count = Math.floor(len / k);
	let hair = new ListNode();
	hair.next = head;
	let pre = hair,
		cur = pre.next;
	while (count--) {
		reverse(pre, cur, k);
		// 每反转一组，要更新 pre 和 cur
		pre = cur;
		cur = cur.next;
	}
	return hair.next;
};
const getListLength = head => {
	let cur = head;
	let i = 0;
	while (cur) {
		cur = cur.next;
		i++;
	}
	return i;
};

const reverse = (pre, cur, k) => {
	//k个点，反转 k-1 次相邻两个节点
	while (--k) {
		// 反转相邻两个节点
		let nxt = cur.next;
		cur.next = nxt.next;
		nxt.next = pre.next;
		pre.next = nxt;
	}
};
```

## 93. 复原 IP 地址|回溯|深搜|dfs

### 题目描述

```有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。
给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。
```

### 解题思路

就是自己定 . 的位置，只要有效就保留

那么每个情况都要尝试 —— 回溯法
特殊情况：

- 已经找了四段
- 遍历完了字符串
- 0

segStart 和 segEnd 为某段的起始位、结束位

### 代码

```js
/**
 * @param {string} s
 * @return {string[]}
 */
var restoreIpAddresses = function (s) {
	const LIMIT = 4;
	const tmpSegments = new Array(LIMIT);
	const ans = [];
	// 初始字符串、当前第几段、当前段起始位
	const dfs = (s, segId, segStart) => {
		if (segId === LIMIT) {
			if (segStart === s.length) {
				ans.push(tmpSegments.join('.'));
			}
			return;
		}
		if (segStart === s.length) return;
		if (s.charAt(segStart) === '0') {
			tmpSegments[segId] = 0; //不能有前导0，所以当前为0就是该段为0
			dfs(s, segId + 1, segStart + 1);
		}
		let addr = 0;
		for (let segEnd = segStart; segEnd < s.length; segEnd++) {
			addr = addr * 10 + (s.charAt(segEnd) - '0');
			if (addr > 0 && addr <= 255) {
				tmpSegments[segId] = addr;
				dfs(s, segId + 1, segEnd + 1);
			} else {
				break;
			}
		}
	};
	dfs(s, 0, 0);
	return ans;
};
```

## 155.最小栈| 栈

### 题目描述

```
设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

实现 MinStack 类:

MinStack() 初始化堆栈对象。
void push(int val) 将元素val推入堆栈。
void pop() 删除堆栈顶部的元素。
int top() 获取堆栈顶部的元素。
int getMin() 获取堆栈中的最小元素。
```

### 解题思路

题目要求常数时间，那么自然就不能说找最小值的时候再遍历，而是在每次放东西取东西的时候都要记录好

那么单单一个栈是不可能做到的，所以我们来用两个栈

- 一个存放所有的元素
- 一个专门用来记录最小值
  - push 时，如果小于（应该是小于等于）栈顶就放进去，不然不放
  - pop 时，判断是否就是栈顶（这里应该是 值和栈顶相等），如果是，那就要 pop 掉

### 代码

```js
var MinStack = function () {
	this.stack = [];
	this.minStk = [];
};

/**
 * @param {number} val
 * @return {void}
 */
MinStack.prototype.push = function (val) {
	this.stack.push(val);
	if (this.minStk.length === 0 || val <= this.minStk[this.minStk.length - 1]) {
		this.minStk.push(val);
	}
};

/**
 * @return {void}
 */
MinStack.prototype.pop = function () {
	const val = this.stack.pop();
	if (val !== void 0 && val === this.minStk[this.minStk.length - 1]) {
		this.minStk.pop();
	}
};

/**
 * @return {number}
 */
MinStack.prototype.top = function () {
	return this.stack[this.stack.length - 1];
};

/**
 * @return {number}
 */
MinStack.prototype.getMin = function () {
	return this.minStk[this.minStk.length - 1];
};
```
