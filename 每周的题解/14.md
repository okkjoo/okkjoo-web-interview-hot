> `okkjoo-leetcodeHot-byJs`带你用 JS 刷高频面试算法题~
> 新增板块 —— 各种常用手写, 最近还加了自己实现的流行库的 mini 版本
> 合集仓库：[okkjoo-leetcodeHot-byJs](https://github.com/okkjoo/okkjoo-leetcodeHot-byJs)
> 如果你已经按题型分类系统地刷

## 902. 最大为 N 的数字组合

### 题目描述

```js

给定一个按 非递减顺序 排列的数字数组 digits 。你可以用任意次数 digits[i] 来写的数字。例如，如果 digits = ['1','3','5']，我们可以写数字，如 '13', '551', 和 '1351315'。

返回 可以生成的小于或等于给定整数 n 的正整数的个数 。
```

### 解题思路

数位 DP + 二分

题目说了 digits 是从 1 到 9 的树，没有 0 就好

就是求 digits 中取数合成的数值范围在 [1,n]之间的有多少个

注意合成的数值重复是只算一个的

设 dp[x]表示返回的合法数的个数，那么区间(l,r)的合法数个数就是
`ans(l-r) = dp(r) - dp(l-r)`

要注意的是，0 是最高位，len-1 是最低位（len 为 n 的长度）

从样例 2 的解释中，我们可以了解到，合法数大概分为这么几类：

- a: 位数和 n 相同的，最高位小于 x 最高位
- b: 位数相同，最高位相同的
- c: 位数小于的

第一个和第三个很简单，主要是中间那个不好说

设 cur 为 n 中第 k 位的数字，要想合成的数字小于 n，那就必须第 k 位在`[1,cur-1]`这个区间取一个数字。那从 digits 中抽取就好了，找满足这个区间，也就是小于 cur 的最大下标，就设它为 t 吧

题目说了 digits 是有序的，所以上一步中可以使用二分查找来进行优化(其实就 9 个数字，也优化不了多少，啊还增加代码长度，我懒得写了)

- digits[t] < cur : 之后的每个位置都有 m 个选择（m 为 digits 长度），`m^q`个选择，
- digits[t] == cur ：实际上已经算过了，就是前一位时的小于 cur 情况嘛，直接从前一位的 dp[i+1]里面拿就好了，累加一下
- 大于的情况，直接不合法了，0 个，不算就好了

### 代码

```js
/**
 * @param {string[]} digits
 * @param {number} n
 * @return {number}
 */
var atMostNGivenDigitSet = function (digits, n) {
	const s = n + ''; //转为字符串
	const len = s.length,
		m = digits.length;
	const dp = new Array(len + 1).fill(0);
	dp[len] = 1; //只有最低位时当然只有一个
	//位数相同的情况，从最低位开始往前
	for (let i = len - 1; i >= 0; i--) {
		let cur = s[i];
		for (let j = 0; j < digits.length; j++) {
			//小于的话直接加
			if (digits[j] < cur) {
				dp[i] += Math.pow(m, len - 1 - i);
			}
			//相同直接从前一位拿
			else if (digits[j] == cur) {
				dp[i] += dp[i + 1];
			}
		}
	}
	// 位数小于 n 的情况
	for (let i = 1; i < len; i++) {
		dp[0] += Math.pow(m, i);
	}
	retur
```
