> `okkjoo-leetcodeHot-byJs`带你用 JS 刷高频面试算法题~
> 新增板块 —— 各种常用手写, 最近还加了自己实现的流行库的 mini 版本
> 合集仓库：[okkjoo-leetcodeHot-byJs](https://github.com/okkjoo/okkjoo-leetcodeHot-byJs)
> 如果你已经按题型分类系统地刷

## 902. 最大为 N 的数字组合

### 题目描述

```js

给定一个按 非递减顺序 排列的数字数组 digits 。你可以用任意次数 digits[i] 来写的数字。例如，如果 digits = ['1','3','5']，我们可以写数字，如 '13', '551', 和 '1351315'。

返回 可以生成的小于或等于给定整数 n 的正整数的个数 。
```

### 解题思路

数位 DP + 二分

题目说了 digits 是从 1 到 9 的树，没有 0 就好

就是求 digits 中取数合成的数值范围在 [1,n]之间的有多少个

注意合成的数值重复是只算一个的

设 dp[x]表示返回的合法数的个数，那么区间(l,r)的合法数个数就是
`ans(l-r) = dp(r) - dp(l-r)`

要注意的是，0 是最高位，len-1 是最低位（len 为 n 的长度）

从样例 2 的解释中，我们可以了解到，合法数大概分为这么几类：

- a: 位数和 n 相同的，最高位小于 x 最高位
- b: 位数相同，最高位相同的
- c: 位数小于的

第一个和第三个很简单，主要是中间那个不好说

设 cur 为 n 中第 k 位的数字，要想合成的数字小于 n，那就必须第 k 位在`[1,cur-1]`这个区间取一个数字。那从 digits 中抽取就好了，找满足这个区间，也就是小于 cur 的最大下标，就设它为 t 吧

题目说了 digits 是有序的，所以上一步中可以使用二分查找来进行优化(其实就 9 个数字，也优化不了多少，啊还增加代码长度，我懒得写了)

- digits[t] < cur : 之后的每个位置都有 m 个选择（m 为 digits 长度），`m^q`个选择，
- digits[t] == cur ：实际上已经算过了，就是前一位时的小于 cur 情况嘛，直接从前一位的 dp[i+1]里面拿就好了，累加一下
- 大于的情况，直接不合法了，0 个，不算就好了

### 代码

```js
/**
 * @param {string[]} digits
 * @param {number} n
 * @return {number}
 */
var atMostNGivenDigitSet = function (digits, n) {
	const s = n + ''; //转为字符串
	const len = s.length,
		m = digits.length;
	const dp = new Array(len + 1).fill(0);
	dp[len] = 1; //只有最低位时当然只有一个
	//位数相同的情况，从最低位开始往前
	for (let i = len - 1; i >= 0; i--) {
		let cur = s[i];
		for (let j = 0; j < digits.length; j++) {
			//小于的话直接加
			if (digits[j] < cur) {
				dp[i] += Math.pow(m, len - 1 - i);
			}
			//相同直接从前一位拿
			else if (digits[j] == cur) {
				dp[i] += dp[i + 1];
			}
		}
	}
	// 位数小于 n 的情况
	for (let i = 1; i < len; i++) {
		dp[0] += Math.pow(m, i);
	}
	retur
```

## 1700. 无法吃午餐的学生数量

### 题目描述

```js
学校的自助午餐提供圆形和方形的三明治，分别用数字 0 和 1 表示。所有学生站在一个队列里，每个学生要么喜欢圆形的要么喜欢方形的。
餐厅里三明治的数量与学生的数量相同。所有三明治都放在一个 栈 里，每一轮：

如果队列最前面的学生 喜欢 栈顶的三明治，那么会 拿走它 并离开队列。
否则，这名学生会 放弃这个三明治 并回到队列的尾部。
这个过程会一直持续到队列里所有学生都不喜欢栈顶的三明治为止。

给你两个整数数组 students 和 sandwiches ，其中 sandwiches[i] 是栈里面第 i​​​​​​ 个三明治的类型（i = 0 是栈的顶部）， students[j] 是初始队列里第 j​​​​​​ 名学生对三明治的喜好（j = 0 是队列的最开始位置）。请你返回无法吃午餐的学生数量。


```

### 解题思路

就是简单的模拟，学生喜爱和栈顶匹配的话就拿走，不匹配的话学生就到队尾去

什么时候会导致有学生吃不了？就是栈顶的三明治没人要了，所有人都搁那轮着排队。所以都不用模拟学生去队尾的过程

等到栈顶的三明治没人要了，剩下的三明治的数量就是没午饭吃的学生数量

怎么表示三明治的数量，就是总数 - 已经从栈顶拿走的数量

### 代码

```js
/**
 * @param {number[]} students
 * @param {number[]} sandwiches
 * @return {number}
 */
var countStudents = function (students, sandwiches) {
	const need = new Array(2).fill(0); //两种三明治的需求
	for (const v of students) need[v]++;
	for (let i = 0; i < sandwiches.length; i++) {
		if (--need[sandwiches[i]] == -1) return sandwiches.length - i;
	}
	return 0;
};
```
