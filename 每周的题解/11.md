> `okkjoo-leetcodeHot-byJs`带你用 JS 刷高频面试算法题~
> 新版板块 —— 各种常用手写
> 合集仓库：[okkjoo-leetcodeHot-byJs](https://github.com/okkjoo/okkjoo-leetcodeHot-byJs)
> 如果你已经按题型分类系统地刷了一遍算法面试题的各个题型，想感受一下面试题的”随机性”的话，欢迎一起~ 欢迎 star⭐

本周开始，试着每天的每日一题，开阔一下做题思路：

## [面试题 17.19. 消失的两个数字](https://leetcode.cn/problems/missing-two-lcci/)

### 题目描述

```
给定一个数组，包含从 1 到 N 所有的整数，但其中缺了两个数字。你能在 O(N) 时间内只用 O(1) 的空间找到它们吗？

以任意顺序返回这两个数字均可。
```

### 解题思路|原地 hash

首先，数组包含 1 到 N 的所有整数，但是 N 并不是它传进来的。N 是什么情况大概分为这么几种：

- 出现了的最大数为 n(n>2)，数组中有两个小于 n 的数字没出现，那么 N 就是 n，答案就是那两个没出现的数字
- 只有一个小于 n 的数字没出现 —— N 就是 n+1，答案就是那个数字和 n+1
- 1~n 都出现了，那么 N 就是 n+2，答案就是 n+1 和 n+2

`O(1)`空间，就是说不可以用 `set`什么的来另外存储 —— 所以我们可以直接在原数组中操作！

既然是 1~n，那么出现了 v ，我们就在数组下标为 v-1 的位置做标记

但是这个标记还不能影响到后续的遍历，那就把他标记为负号，遍历的时候微微操作一下取绝对值就好

最后 遍历一下前面非负数的地方，就是未出现的~

遍历了两次 2\*N，常熟\*N 还是算 O(N)时间复杂度滴~

#### 注意

注意当下标定位到原先不存在的的下标时，就会出现 empty item 或者 NaN，结果就不对了
所以还要特殊处理一下

### 代码

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var missingTwo = function (nums) {
	let res = [],
		mxV = -1;
	const len = nums.length;
	for (let i = 0; i < len; i++) {
		let v = Math.abs(nums[i]);
		mxV = Math.max(mxV, v);
		nums[v - 1] = -(nums[v - 1] || 1);
	}
	for (let i = 0; i < nums.length; i++) {
		let v = nums[i] || 1;
		if (v > 0 || v === undefined) {
			res.push(i + 1);
		}
	}
	while (res.length < 2) res.push(++mxV);
	return res;
};
```

## 面试题 01.02. 判定是否互为字符重排

### 题目描述

```
给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。
```

### 解题思路

判断重新排列后能不能变 —— 那不就是看字符串中各个字母出现的次数一不一样咯

一样就是可以

### 代码

```js
/**
 * @param {string} s1
 * @param {string} s2
 * @return {boolean}
 */
var CheckPermutation = function (s1, s2) {
	const mp = new Map();
	for (let c of s1) mp.set(c, (mp.get(c) || 0) + 1);
	for (let c of s2) mp.set(c, (mp.get(c) || 0) - 1);
	for (let v of mp.values()) {
		if (v !== 0) return false;
	}
	return true;
};
```
