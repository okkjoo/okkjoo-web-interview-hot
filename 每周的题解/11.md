> `okkjoo-leetcodeHot-byJs`带你用 JS 刷高频面试算法题~
> 新版板块 —— 各种常用手写
> 合集仓库：[okkjoo-leetcodeHot-byJs](https://github.com/okkjoo/okkjoo-leetcodeHot-byJs)
> 如果你已经按题型分类系统地刷了一遍算法面试题的各个题型，想感受一下面试题的”随机性”的话，欢迎一起~ 欢迎 star⭐

本周开始，试着每天的每日一题，开阔一下做题思路：

## [面试题 17.19. 消失的两个数字](https://leetcode.cn/problems/missing-two-lcci/)

### 题目描述

```
给定一个数组，包含从 1 到 N 所有的整数，但其中缺了两个数字。你能在 O(N) 时间内只用 O(1) 的空间找到它们吗？

以任意顺序返回这两个数字均可。
```

### 解题思路|原地 hash

首先，数组包含 1 到 N 的所有整数，但是 N 并不是它传进来的。N 是什么情况大概分为这么几种：

- 出现了的最大数为 n(n>2)，数组中有两个小于 n 的数字没出现，那么 N 就是 n，答案就是那两个没出现的数字
- 只有一个小于 n 的数字没出现 —— N 就是 n+1，答案就是那个数字和 n+1
- 1~n 都出现了，那么 N 就是 n+2，答案就是 n+1 和 n+2

`O(1)`空间，就是说不可以用 `set`什么的来另外存储 —— 所以我们可以直接在原数组中操作！

既然是 1~n，那么出现了 v ，我们就在数组下标为 v-1 的位置做标记

但是这个标记还不能影响到后续的遍历，那就把他标记为负号，遍历的时候微微操作一下取绝对值就好

最后 遍历一下前面非负数的地方，就是未出现的~

遍历了两次 2\*N，常熟\*N 还是算 O(N)时间复杂度滴~

#### 注意

注意当下标定位到原先不存在的的下标时，就会出现 empty item 或者 NaN，结果就不对了
所以还要特殊处理一下

### 代码

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var missingTwo = function (nums) {
	let res = [],
		mxV = -1;
	const len = nums.length;
	for (let i = 0; i < len; i++) {
		let v = Math.abs(nums[i]);
		mxV = Math.max(mxV, v);
		nums[v - 1] = -(nums[v - 1] || 1);
	}
	for (let i = 0; i < nums.length; i++) {
		let v = nums[i] || 1;
		if (v > 0 || v === undefined) {
			res.push(i + 1);
		}
	}
	while (res.length < 2) res.push(++mxV);
	return res;
};
```

## 面试题 01.02. 判定是否互为字符重排

### 题目描述

```
给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。
```

### 解题思路

判断重新排列后能不能变 —— 那不就是看字符串中各个字母出现的次数一不一样咯

一样就是可以

### 代码

```js
/**
 * @param {string} s1
 * @param {string} s2
 * @return {boolean}
 */
var CheckPermutation = function (s1, s2) {
	const mp = new Map();
	for (let c of s1) mp.set(c, (mp.get(c) || 0) + 1);
	for (let c of s2) mp.set(c, (mp.get(c) || 0) - 1);
	for (let v of mp.values()) {
		if (v !== 0) return false;
	}
	return true;
};
```

## 面试题 17.09. 第 k 个数|归并排序|三指针

### 题目描述

```
有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。

```

### 解题思路

说实话，第一次看题目真没看懂

题目意思应该是 这种数的素数因子中只能有 3 5 7，比如 11 有个素数因子为 11，就不满足

ok，那意思就是 这种数 x3 x5 x7 后会得到更大的这种数~

那么假设第一个数是 `k[0]`
那么后面的数就是分别为

```js
k[0]*3,k[1]*3,k[2]*3,k[3]*3...
k[0]*5,k[1]*5,k[2]*5,k[3]*5...
k[0]*7,k[1]*7,k[2]*7,k[3]*7...
```

这三个数列合在一起，就是题意中的 `1，3，5，7，9，15，21...`

合起来 —— 按顺序合起来，重复的要去掉~ 欸注意，这三个数列，分别也都是有顺序的！

是不是有点像这题 [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array)

那题两个指针来归并排序，那这题就是三个指针来归并排序哩

### 代码

```js
/**
 * @param {number} k
 * @return {number}
 */
var getKthMagicNumber = function (k) {
	let arr = [1];
	let j3 = 0,
		j5 = 0,
		j7 = 0;
	for (let i = 1; i < k; i++) {
		let a = arr[j3] * 3,
			b = arr[j5] * 5,
			c = arr[j7] * 7;
		arr[i] = Math.min(a, b, c);
		if (arr[i] === a) j3++;
		if (arr[i] === b) j5++;
		if (arr[i] === c) j7++;
	}
	return arr[k - 1];
};
```

## 面试题 01.09. 字符串轮转

### 题目描述

```
字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。
```

### 解题思路

一开始我以为和这题[面试题 01.02. 判定是否互为字符重排] 一样，判断字符串中字符出现频数一样就好，但是 并不是。

仔细看了看，他这个“旋转”

就是整个字符串像双向队列一样，前面的字符依次从前面退出后依次从后面进入

本来打算双指针一个个遍历模拟比对，感觉有点复杂，但是这是简单题，还说只能检测一次字串 🤔

既然是像双向队列一样，那我直接把 s1 重复两次，如果 s2 是可以从 s1“旋转”得来的，那不就能从 `2*s1 `中找到子串是 s2 嘛

当然，search 这个 API，你可以尝试自己实现一下~ 反正我是觉得这题核心是想到 `s2`是`2*s1`子串

### 代码

```js
/**
 * @param {string} s1
 * @param {string} s2
 * @return {boolean}
 */
var isFlipedString = function (s1, s2) {
	if (s1.length !== s2.length) return false;
	const s = s1 + s1;
	return s.search(s2) !== -1;
};
```
