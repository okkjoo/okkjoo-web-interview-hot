> `okkjoo-leetcodeHot-byJs`带你用 JS 刷高频面试算法题~
> 还有各种常用、常考手写, 最近还加了自己实现的流行库的 mini 版本
> 合集仓库：[okkjoo-leetcodeHot-byJs](https://github.com/okkjoo/okkjoo-leetcodeHot-byJs)
> 欢迎 star⭐

## 1662. 检查两个字符串数组是否相等

### 题目描述

```
给你两个字符串数组 word1 和 word2 。如果两个数组表示的字符串相同，返回 true ；否则，返回 false 。

数组表示的字符串 是由数组中的所有元素 按顺序 连接形成的字符串。
```

### 解题思路

纯纯模拟判断

可以直接用 JavaScript 的 join API

也可以自己写一个 —— 写一个也不难

还可以直接用指针遍历，无非就是特殊判断一下每项里的字符串有多长罢了，可以将空间复杂度优化为 1，我懒

### 代码

```js
/**
 * @param {string[]} word1
 * @param {string[]} word2
 * @return {boolean}
 */
var arrayStringsAreEqual = function (word1, word2) {
	const join = word => {
		let s = '';
		for (const c of word) s += c;
		return s;
	};
	return join(word1) === join(word2);
};
```

## 110. 平衡二叉树

### 题目描述

```
给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。
```

### 解题思路

从上到下：递归遍历暴力获取当前节点最大深度，判断当前子树是否平衡+左右子树是否平衡，简单，但时间复杂度可能为 O(NlogN)—— **因为每层高度都要重复计算**

```js
var isBalanced = function (root) {
	if (root === null) return true;
	const depth = root => {
		if (root === null) return 0;
		return Math.max(depth(root.left), depth(root.right)) + 1;
	};
	return (
		Math.abs(depth(root.left) - depth(root.right)) <= 1 &&
		isBalanced(root.left) &&
		isBalanced(root.right)
	);
};
```

从下到上：从底到顶返回子树最大高度，如果子树不是平衡树就直接 false 了
左右子树高度差大于等于 2，直接返回-1 表示不行

不然就返回左右子树中深的那个长度+1（每个节点都能利用到之前计算过的）

> 后序遍历的意思

### 代码

```js
var isBalanced = function (root) {
	const recur = root => {
		if (root === null) return 0;
		const left = recur(root.left);
		if (left === -1) return -1;
		const right = recur(root.right);
		if (right === -1) return -1;
		return Math.abs(left - right) < 2 ? Math.max(left, right) + 1 : -1;
	};
	return recur(root) !== -1;
};
```
